# ecs-fargate-in-vpc

Infrastructure template for deploying an application on ECS Fargate with RDS and CodePipeline, using different configurations for production and development environments.

## Overview
This infrastructure template deploys an application on Amazon ECS Fargate with a focus on providing production-grade resilience and security features. The template is designed to dynamically adapt its configuration based on the environment (development, staging, or production), specifically in how it manages networking resources.

## Architecture
The architecture consists of:
- A VPC organized into public and private subnets.
- An ECS Fargate cluster to run application containers.
- An RDS instance for database storage, configured to use a NAT Gateway in production and a NAT instance for development and staging.
- AWS CodePipeline to manage the deployment of the application on ECS.

## Supported Environments
This template supports the following environments:
- **Development:** Uses NAT instance for network traffic.
- **Staging:** Uses NAT instance for network traffic.
- **Production:** Uses NAT Gateway for improved availability and security.

## Inputs / Outputs
### Variables
| Name           | Type    | Default | Description                        |
|----------------|---------|---------|------------------------------------|
| `env`         | string  | `prod`  | Environment (prod/staging/dev)    |
| `app_name`    | string  | `myapp` | Application/service name            |
| `rds_password`| string  |         | Database password (sensitive)      |

### Outputs
| Name                  | Description                   |
|-----------------------|-------------------------------|
| `vpc_id`              | ID of the created VPC       |
| `security_group_id`   | ID of the security group    |
| `ecs_cluster_name`    | Name of the ECS cluster     |
| `rds_endpoint`        | Endpoint of the RDS instance|

## Prerequisites
- AWS account with permissions to create VPC, ECS, RDS, and other services used.
- AWS CLI configured for the region specified in variables.

## Backend Setup
This template uses S3 for remote state storage. Before deploying, ensure that your S3 bucket is created and replace `PLACEHOLDER` in backend.tf with your actual bucket name and path.

## Environment Bootstrapping
Command to deploy:
```bash
make plan ENV=dev
make apply ENV=dev
```
You can replace `dev` with `staging` or `prod` as needed.

## Common Workflows
To plan changes:
```bash
make plan ENV=prod
```
To destroy resources:
```bash
make destroy ENV=staging
```
To view outputs:
```bash
make outputs ENV=prod
```

## Cleanup Instructions
To remove all created resources:
```bash
make destroy ENV=prod
```
This will destroy the entire stack in the specified environment.

**Made with love using AI in [Senora.dev](https://senora.dev) platform.**

## Environment Variables

This project uses environment-specific variable files in the `envs/` directory.

### dev
Variables are stored in `envs/dev/terraform.tfvars`



## GitHub Actions CI/CD

This project includes automated Terraform validation via GitHub Actions.

### Required GitHub Secrets

Configure these in Settings > Secrets > Actions:

- `AWS_ACCESS_KEY_ID`: Your AWS Access Key ID
- `AWS_SECRET_ACCESS_KEY`: Your AWS Secret Access Key
- `TF_STATE_BUCKET`: S3 bucket name for Terraform state
- `TF_STATE_KEY`: Path to state file in S3 bucket

ðŸ’¡ **Tip**: Check your `backend.tf` file for the bucket and key values.


---
*Generated by [Senora](https://senora.dev)*
